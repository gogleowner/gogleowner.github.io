---
layout: post
title: "codecomplete 2부(5~8장 정리)"
date: 2018-06-12 15:30:00 +0900
categories: book
---

[CodeComplete](http://www.yes24.com/24/goods/44130507?scode=032&OzSrank=1) 책의 2부중 5~8장을 정리했다.

# 2부 고품질 코드 작성

## 5장 구현설계
```
- S/W의 주요 기술적 의무는 복잡성을 관리하는 것. 단순함에 초점을 맞춘 설계로 큰 도움을 받을 수 있다.
- 단순함 -> 한번에 뇌에서 처리해야하는 본질적인 복잡성의 양을 최소화하는 것과 부수적인 복잡성이 불필요하게 증가하지 않도록 하는 것
- 설계는 발견적 학습이다. 한가지 방법론에만 독단적으로 집착하면 독창성과 프로그램에 해가 된다.
- 좋은 설계는 반복적이다. 여러번 시도할수록 최종 설계는 더 좋아질 것이다.
- 정보은닉은 매우 유용한 개념이다. "무엇을 숨겨야하지? 라는 질문이 해결하기 어려운 설계 상의 문제를 해결해준다.
```

### 5.1.설계의 어려움

- 설계
	- 단순히 상세 부분을 작성하기 전 의사코드(pseudo code)로 클래스 인터페이스를 작성하는 것
	- 다른 개발자에게 어떤 디자인 패턴이 더 좋은지 물어보는 것
	- 설계를 어떻게 하든, 프로젝트 규모에 상관없이 신중하게 설계하면 좋은 점이 있고 설계를 명백하게 수행하는 작업으로 인식하고 진행하면 그로부터 얻는 혜택이 최대화될 것임

- 설계는 불명확한 문제다
	- 불명확한 : 전체 혹은 일부를 해결해야만 정의할 수 있는 문제
		- 예 : 무너진 타코마다리 -> 다리를 지을 당시에는 견고함을 유지할 수 있었으나 바람이 많이 불어 무너지게 됨. 엔지니어는 공기역학을 그 범위까지 적용해야했었는지 알지 못했기 때문.
- 설계는 엉성한 프로세스다(결과는 정돈되었을지라도)
	- 설계하면서 잘못된 길로 들어서는 경우도 많고 실수도 많이 하기에 설계는 엉성한 것
	- 사실 실수를 하는 것이 설계의 핵심
		- 설계 단계에서 실수하고 고치는 것이 똑같은 실수를 코드 작성 후에 발견하여 코드 수정하는 것보다 비용이 적게 듦
	- 설계는 "충분"한 상태를 알기 어렵기 때문에 엉성해 보이기도 함

- 설계는 절충과 우선순위의 문제다
- 설계에는 제약이 따른다
	- 설계의 핵심은 어느정도의 가능성을 만들고 어느정도는 가능성을 제한하는데 있다.

- 설계는 비결정적이다
	- 세사람에게 같은 문제를 설계하도록 하면 서로 완전히 다른 설계를 내놓겠지만 모두 충분히 쓸만할 것
	- 프로그램을 설계하는 방법은 수십가지에 이른다.

- 설계는 발견적 학습 과정이다
	- 설계는 예상된 결과를 만들어내는 반복적인 처리 과정이라기 보다 발견적 학습이다
		- 경험 법칙 또는 작동하는지 시도해 보는 것

- 설계는 창발적이다
	- 설계는 누군가의 머리속에서 완전한 형태로 갑자기 솟아 나오지 않고, 설계 검토와 격식없는 토론, 코드 작성 경험 자체, 코드 수정 경험을 통해 진화하고 발전한다


### 5.2 핵심 설계 개념
- 소프트웨어의 주요 기술적 의무: 복잡성 관리
	- 본질적 어려움과 비본질적 어려움
		- 비본질적 어려움 : 브룩스(Brooks 1987) S/W의 비본질적 어려움이 오래 전에 해결되었음을 발견함
			- 언어 문법, 기술의 발전으로 인해서 어느정도 해결됨
		- 본질적 어려움 : 느리게 해결될 수 밖에 없다고 주장함
			- S/W개발이 본질적으로 매우 복잡하고 서로 연관된 개념들에 관한 세부사항들을 해결하는 작업이기 때문
			- 현실세계에서 사물 간의 상호작용이 매우 복잡해짐에 따라 S/W 솔루션의 본질적인 어려움도 증가
	- 복잡성 관리의 중요성
		- 대부분의 실패한 프로젝트는 요구사항이나 계획수립, 관리가 부족해서 실패함
		- 프로젝트가 기술적으로 실패했다고 보고하는 경우는 거의 없으나 기술적인 이유로 실패한 경우에는 복잡성 관리 부족에서 원인을 찾을 수 있음
			- S/W는 무슨 일이 일어나는지 아무도 모를 정도로 복잡성이 증가할 수 있음
			- 프로젝트에서 한 영역의 코드를 변경했을때 다른 부분에 어떤 영향을 미치는지 완벽하게 이해하는 사람이 없을 정도라면 더이상 개발을 할 수 없을 지경에 이른 것임
		- S/W 아키텍처에서는 시스템을 서브시스템으로 나누어 문제의 복잡성을 줄인다.
		- 인간은 하나의 복잡한 부분보다 여러개의 간단한 정보를 더 빠르게 이해한다.
		- 모든 S/W 설계 기법의 목표는 복잡한 문제를 간단한 문제로 나누는 것이다.
	- 복잡성 해결 방법
		- 비효과적인 설계
			- 간단한 문제를 복잡하게 해결할 때
			- 복잡한 문제를 단순하고 잘못된 방법으로 해결할 때
			- 복잡한 문제를 부적절하고 복잡하게 해결할 때
		- 복잡성 관리하는 접근방법
			- 두뇌가 한 번에 처리해야 하는 본질적인 복잡성의 양을 최소화
			- 비본질적인 복잡성이 불필요하게 증가하지 않도록 한다
- 바람직한 설계의 특징
	- 복잡성 최소화 : 간단하고 이해하기 쉬운 설계
	- 유지보수의 편리함 : 유지보수 개발자를 위해 고려한 설계
	- 느슨한 결합
		- 프로그램의 각 부분 사이의 연결을 최소화하는 설계
		- 클래스 사이의 연결을 최소화하기 위해 클래스 인터페이스에서의 추상화, 캡슐화, 정보은닉 등을 사용
	- 확장성
		- 내부 구조를 해치지 않고 시스템의 기능을 개선
		- 예측 가능한 변경사항을 미리 고민하면 시스템에 입히는 충격을 최소화할 수 있음
	- 재사용성 : 현재 시스템의 일부를 다른 시스템에 사용할 수 있게 시스템을 설계
	- 높은 팬인(fan-in), 낮은 팬아웃(fan-out)
		- 높은 팬인(fan-in) : 특정 클래스를 사용하는 클래수가 많음
		- 낮은 팬아웃(fan-out) : 특정 클래스가 다른 클래스를 적게 사용
		- 높은 팬아웃은 한 클래스가 다른 클래스를 여러개 사용한다는 것을 가리킴 -> 지나치게 복잡할 것
	- 이식성 : 시스템을 다른 환경으로 쉽게 이동시킬 수 있도록 설계
	- 간결성 : 불필요한 부분이 없게 시스템을 설계
	- 계층화 : 특정한 계층에서 바라보고 일관되게 이해할 수 있도록 분산 계층을 유지하는 것
	- 표준기법들 : 시스템이 색다른 방법에 의존하면 할수록 다른 사람이 처음에 코드를 이해하기가 더 어려워질 것

- 설계 수준(Top-Down)
	- 소프트웨어 시스템 : 전체시스템
	- 서브시스템이나 패키지로 분할 : 서로 다른 서브 시스템이 어떻게 서로 소통할 것인지에 대한 규칙을 정해야함
		- 공통적인 서브시스템
			- 비즈니스 규칙 : 컴퓨터 시스템에 입력하는 법률,규칙,정책,절차
			- 사용자 인터페이스 : 사용자가 프로그램의 나머지에 지장을 주지 않고 발전할 수 있도록 사용자 인터페이스 컴포넌트를 고립시키는 서브시스템 개발
			- 데이터베이스 접근 : 구현 세부사항을 감추고 db연산을 한곳에 모은다
			- 시스템 의존성 : H/W의 의존성을 패키지화
	- 클래스로 분할
		- 객체지향 설계의 가장 핵심적인 개념은 객체와 클래스의 차이를 이해하는데 있음
			- 객체 : 실행 중인 프로그램에 존재하는 구체적 엔티티
			- 클래스 : 프로그램 코드로 정적이지만 객체는 프로그램을 실행할 때 생성되는 특정한 값과 속성을 갖는 동적인 것

	- 루틴으로 분할
		- 클래스를 루틴으로 나눔
	- 내부 루틴 설계
		- 각 루틴의 상세한 기능을 설계

### 5.3. 설계 빌딩 블록 : 발견적 학습
- 현실세계의 객체를 찾아라
	- 객체 설계단계
		- 객체와 객체의 속성(메소드와 데이터) 식별
		- 각 객체에 무엇을 할 수 있는지 결정
		- 각 객체가 다른 객체에 무엇을 할 수 있는지 결정
		- 각 객체에서 다른 객체에 보일, 안보일 부분을 결정
		- 각 객체의 공개 인터페이스를 정의
- 일관성 있게 추상화
	- 추상화 : 세부 사항을 무시해도 문제가 없는 개념과 맞물리는 능력
	- 기초(Base)클래스는 기초 클래스에 대해 작업할 때 상속받은 클래스가 갖는 공통 특성들에 집중하고 다른 세부 사항은 무시하기 위해 만들어진 추상화
		- 클래스의 내부 작업에 신경 쓰지 않고 인터페이스에 집중할 수 있게 하는 설계가 좋은 추상화
- 구현 세부 사항을 캡슐화
	- 캡슐화 : 다른 수준에서 해당 객체를 특정 수준 이상으로 볼 수 없도록 하는 것. 복잡한 부분을 보지 못하게 함으로써 복잡성을 관리하는 데 도움을 줌
		- 추상화 : 객체를 높은 수준에서 볼 수 있도록 함
- 상속이 설계를 단순화할 수 있을 때 상속하라
	- 상속은 프로그래밍을 단순화한다.
		- 문을 예로 들면 
			- 일반적 특성에 의존하는 처리루틴 : open(), close() 
			- 특정 종류의 문에 대한 특정 작업 처리 루틴 : 실내문 / 실외문 / 유리문 / 미닫이문
		- 문의 종류에 상관없이 open(), close()와 같은 연산을 지원하는 언어의 특성을 다형성이라고 함
- 정보 은닉
	- 구조적 설계 : 블랙박스
	- 객체지향적 설계 : 캡슐화, 모듈성 개념, 추상화 개념과 연결
	- 비밀, 프라이버시
		- 정보은닉 관점에서 각 클래스는 다른 클래스로부터 숨기는 설계, 구현 결정으로 특정지어짐
		- 어떤 기능을 외부로 알리고 어떤 기능을 비밀로 남길지를 결정
	- 은닉의 종류
		- 특별하게 관심이 없는 경우에 고민할 필요가 없도록 복잡성을 감추는 것
		- 변경이 발생했을 때 그 효과가 일부에만 영향이 미치도록 변경의 원인을 감추는 것
	- 정보 은닉의 장애물
		- 정보의 지나친 배분
			- 여러곳에서 참조하는 상수 값
		- 순환 의존성
			- 클래스 A에 있는 루틴이 클래스B의 루틴을 호출하고 클래스B의 루틴이 클래스A의 루틴을 호출하는 경우가 없어야함
		- 전역데이터로 오해받는 클래스 데이터
			- 전역데이터가 유발할 수 있는 문제점
				- 다른 루틴이 전역 데이터를 다루고 있다는 사실을 알지 못한체 전역데이터에 접근하는 경우
				- 다른 루틴이 전역 데이터를 다루고 있다는 것을 알고 있지만 정확하게 무엇을 하는지 알지 못하는 경우
			- 프로그램이 10개 정도의 루틴이 들어있는 큰 클래스를 사용하도록 설계되어 있다면 클래스데이터와 전역 데이터 사이의 구분이 불분명해지고 클래스 데이터가 전역데이터와 비슷한 문제를 유발하기 쉬움
	- 성능 손해
		- 코드 수준에서 성능 개선을 미리 준비하는 가장 좋은 방법은 코드를 모듈화하는데에 있음
		- 병목지점 발견시 시스템의 다른 부분에는 영향을 주지 않고 개별적인 클래스와 루틴을 최적화할 수 있음
	- 정보 은닉의 가치
		- 고유한 특성에 기반을 두고 발견적인 방법으로 좋은 설계를 돕는다.
		- 클래스의 공개 인터페이스를 설계할 때 유용할 수 있음
		- 무엇을 숨겨야하는지에 대한 고민 & 질문은 모든 수준에서 좋은 설계 결정에 도움을 줌

- 변경될 것 같은 영역을 찾아라
	- 변화에 대비하기 위해 따라야하는 단계
		- 변경될 것처럼 보이는 항목을 찾는다
		- 변경될 것 같은 항목을 분류한다
		- 변경될 것처럼 보이는 항목을 고립시킨다
	- 변경의 정도 예측하기
		- 변경이 발생할 것 같다면 시스템이 그러한 변경을 쉽게 수용할 수 있는지 확인
		- 절대로 변경되지 않을 것 같은 부분만 시스템에서 하나 이상의 클래스에 큰 영향을 미치도록 허용해야함
- 결합을 느슨하게 유지하라
	- 결합 : 클래스와 루틴이 다른 클래스나 루틴과 얼마나 밀접하게 연관되어 있는지를 기술
	- 느슨한 결합(loose coupling) : 다른 클래스나 루틴과 작고 직접적이며 눈에 띄고 유연한 관계를 갖는 클래스와 루틴(모듈)
	- 다른 모듈에 거의 의존하지 않는 모듈 생성하도록 노력해야함
	- 결합의 기준
		- 크기 : 모듈 사이의 연결 횟수
		- 가시성 : 두 모듈 간의 연결이 얼마나 명시적인지
		- 유연성 : 얼마나 쉽게 모듈 사이의 연결을 변경할 수 있는지
			- 어떤 모듈이 다른 모듈을 호출하는게 쉬울수록 결합은 더 느슨해짐. 그렇게 하면 유연성도 커지고 유지보수하기도 쉽기 때문에 좋음
			- 시스템 구조를 설계할때는 상호연결을 최소화하도록 프로그램을 나눠야함
			- 프로그램이 나무토막 하나라면 나무를 깨알같이 쪼개도록 한다
	- 결합의 종류
		- 간단한 데이터 매개변수 결합
			- 두 모듈 사이에 전달되는 모든 데이터가 기본데이터형이고 모든 데이터가 매개변수로 전달된다면 두 모듈은 단순-데이터-매개변수로 결합된 것
		- 간단한 객체 결합
			- 모듈이 객체를 인스턴스화한다면 그 모듈은 객체에 단순-객체로 결합된 것
		- 객체 매개변수 결합
		- 의미론 적 결합
- 일반적으로 널리 사용되는 디자인 패턴을 찾아라
	- 디자인패턴은 S/W에서 가장 흔히 발생하는 많은 문제를 해결하는데 사용할 수 있는 이미 만들어진 솔루션의 핵심적인 부분을 제공
		- 디자인 패턴의 이점
			- 이미 만들어진 추상화를 제공함으로써 복잡성을 줄인다
				- 팩토리메서드 : 팩토리메서드를 제외한 다른 개별적인 파생 클래스를 파악하지 않고도 특정한 기본 클래스로부터 파생 클래스의 인스턴스를 만들 수 있는 패턴
			- 패턴은 일반적으로 널리 사용되는 해결책의 세부사항들을 규정함으로써 오류를 줄인다
			- 패턴은 대안을 제안함으로써 발견적 학습의 가치를 제공한다
			- 패턴은 설계에 대해 수준 높은 논의를 할 수 있게 해서 의사소통을 원활하게 한다.
- 다른 발견적 학습
	- 응집력을 강하게 하라
		- 응집력 : 클래스에 있는 모든 루틴이나 루틴의 모든 코드가 얼마나 밀접하게 중심 목적을 지원하고 있는지, 그 클래스가 얼마나 집중되어있는지를 나타냄
		- 클래스의 코드가 중심 목표를 더 많이 지원할 수록 코드가 수행하는 모든 것을 더 쉽게 기억할 수 있기 때문
	- 계층을 만들어라
		- 단계식 정보구조(Top-Down)
	- 클래스 제약을 형식화 하라
		- 데이터 x,y,z를 제공하기로 약속하고 그 데이터들이 a,b,c라는 특성을 갖는다는 것을 약속한다면 8,9,10이라는 제약 내에서 1,2,3의 연산을 수행할 것을 약속함
	- 책임을 할당하라
		- 객체에 어떻게 책임을 할당할 것인지
	- 테스트가 가능하도록 설계
		- 테스트가 가능토록 설계하면 더 규격화된 클래스 인터페이스가 만들어지는 경향이 있음
	- 실패를 피하라
	- 결합 시점을 의식적으로 선택하라
	- 제어 지점을 정하라
		- PJ.플로거 : 정확한 장소의 법칙 - 중요한 코드를 찾기 위한 정확한 장소와 유지보수 변경을 수행하기 윟나 정확한 장소가 있어야 한다.
	- 주먹구구식 기법의 사용을 고려하라
		- 이진검색이 우아한 방법이지만 주먹구구식 순차검색만으로 충분할 때가 많다.
	- 다이어그램을 그려라
		- 그림을 사용하면 더욱 높은 추상화 수준에서 문제를 표현할 수 있음
	- 모듈화를 유지하라
		- 모듈화의 목표는 각 루틴이나 클래스를 블랙박스처럼 만드는 것

### 5.4. 설계 실천법
- 반복
	- 설계는 반복적인 프로세스이다.
	- 설계를 되풀이할 때마다 전체 설계를 향상시킬 수 있음
- 분할과 정복
	- 프로그램을 서로 다룬 관심영역으로 나누고 각 부분을 개별적으로 처리하도록 한다.
- 하향식, 상향식 설계접근 방법
	- 하향식 설계 : 높은 추상화수준에서 시작
		- 기본 클래스나 구체적이지 않은 다른 설계요소를 정의
			- 설계를 하면서 파생 클래스 규명, 클래스 공동작업, 다른 세부적 설계요소등 상세화 수준을 높임
	- 상향식 설계 : 구체적인 것에서 시작해 일반적인 쪽으로 작업
		- 구체적인 객체를 규명하는 것부터 시작, 그 내용으로부터 객체와 기본 클래스 집합을 일반화함
- 실험적인 프로토타이핑
	- 때로는 구현 세부사항을 제대로 이해하기 전에는 설계가 적합한지 실제로 알수 없는 경우가 있음
	- 제품 코드와 다른 언어로 프로토타이핑을 작성해보는 것
- 협력적인 설계
	- 설계에서는 조직구성이 공식적이든 비공식적이든 상관없이 두명이 한명보다 낫다.
- 설계 작업 기록하기
	- 설계 문서를 코드 자체에 넣어라
		- 코드 주석, JavaDoc, README.md 등
	- 설계에 대한 논의와 결정을 wiki에 기록
	- 이메일로 요약
	- 카메라를 사용
	- 설계 플립차트 보관
	- CRC(클래스, 책임, 협력자)카드 활용
	- UML 다이어그램 작성


## 6장 클래스 다루기

```
- 클래스의 인터페이스는 일관성있는 추상화를 제공해야함. 이 규칙을 어기면 많은 문제가 발생한다.
- 클래스 인터페이스는 시스템 인터페이스나 설계 결정, 구현 세부사항을 숨겨야 한다.
- "is-a" 관계를 모델링하고 있지 않다면 상속보다 포함을 선택하는 것이 좋다
- 상속은 유용한 도구지만 복잡성을 증가시키며 그로 인해 복잡성 관리가 어려워진다.
- 클래스는 복잡성을 관리하기 위해 사용할 수 있는 기본적인 도구이다. 복잡성을 관리할 수 있도록 설계에 많은 주의를 기울여라.
```

### 6.1. 클래스의 토대: 추상 데이터형(Abstract Data Type, ADT)
- ADT : 데이터와 데이터를 처리하는 연산의 집합
	- 연산 : 프로그램의 나머지 부분에 데이터가 무엇인지를 설명해주는 혁할, 나머지 프로그램에서 그 데이터를 변경할 수 있게 해주는 역할
	- 모든 연산이 포함된 그래픽 윈도우 / 파일과 파일 연산, 보험오율표에 필요한 연산
	- ADT 사용의 좋은점
		- 구현 세부사항을 감출 수 있다.
		- 변경이 전체에 영향을 미치지 않는다.
		- 인터페이스가 더 많은 정보를 제공하도록 만들 수 있다.
		- 성능을 향상시키기 쉽다.
		- 프로그램이 명백하게 정확해진다.
		- 프로그램의 가독성이 높아진다.
		- 전체 프로그램에 데이터를 넘길 필요가 없다.
		- 저수준 구현 구조체 대신 현실 세계의 개체를 다룰 수 있다.
	- ADT는 클래스의 기본 개념이 바탕을 이룬다. 프로그래밍 언어가 클래스를 지원하면 ADT를 클래스로 구현할 수 있다. 상속, 다형성이라는 개념도 추가로 지원하기에 ADT에 상속, 다형성을 더한 것을 클래스라 생각하면 된다.

### 6.2. 좋은 클래스 인터페이스
- 좋은 추상화
	- 클래스가 구현하고 있는 추상화가 무엇인지 이해해야함
	- 서로 반대되는 기능을 갖는 서비스 쌍을 제공하라
	- 관련이 없는 정보를 다른 클래스로 옮겨라
	- 가능하면 인터페이스를 의미론적이기보다는 프로그래밍적으로 만들어라
		- 의미론 적인 인터페이스 : RoutineA는 반드시 RoutineB보다 먼저 호출되어야한다. 라는 사항은 Assert 나 다른 기법을 통해 프로그래밍적인 요소로 강제화하는 방법을 모색해본다.
	- 코드 변경시 인터페이스의 추상화가 망가지지 않도록 주의한다
	- 인터페이스 추상화에 맞지 않는 공개 멤버변수를 추가하지 말라
	- 추상화와 응집도를 함께 고려하라
- 좋은 캡슐화
	- 클래스와 멤버 접근성을 최소화하라
	- 멤버 데이터를 public 노출하지 말라
	- 내부 구현 세부 사항을 클래스의 인터페이스에 입력하지 말라
	- 클래스의 사용자를 가정하지 말라
	- friend 클래스를 피하라
		- friend 클래스 : 서로 다른 클래스가 비공개 함수에 접근할수 있도록 선언한 클래스
	- 어떤 루틴이 공개 루틴만 사용한다고 해서 public 인터페이스에 두지 말라
	- 코드를 작성할 때의 편의성보다 가독성이 높은 코드를 작성하라
	- 캡슐화의 의미론적인 위반을 각별히 주의하라
	- 지나치게 밀접한 결합을 주의하라

### 6.3. 설계와 구현 문제

- 포함(has-a 관계)
	- 포함을 통해 "갖다"를 구현하라
	- 최후의 수단으로 비공개 상속을 통해서 has a 를 구현하라
- 상속(is-a 관계)
	- 한 클래스가 다른 클래스의 특별한 형태라는 개념
	- 상속의 목적은 두 개 이상의 파생 클래스에서 공통으로 사용되는 요소를 갖는 기본 클래스를 정의하여 더 간단한 코드를 작성하는 데 있다.
	- 공통적인 요소 : 루틴 인터페이스, 구현부, 데이터 멤버, 데이터형
	- 상속을 사용하기로 했다면?
		- 각 루틴의 경우 루틴이 파생클래스에서 보일 것인가? 기본 구현을 포함할 것인가? 기본 구현의 override 가 가능할 것인가?
		- 각 데이터의 멤버(변수,이름상수,열거형 등) 데이터 멤버가 파생클래스에서 보일 것인가?
	- is a 를 구현
		- 기본 클래스는 파생 클래스가 어떻게 동작할 것인지를 예측하고 ㅍ생클래스가 작동하는 방법에 제약을 가할 수 있다.
	- 상속을 고려해서 설계하고 문서화하라. 그게 아니면 상속을 금지하라
		- 상속은 프로그램을 조금 복잡하게 만들기 때문에 위험한 기법이다.
	- 리스코프 치환 원칙(Liskov Substitution Principle)
		- 파생클래스가 기본 클래스의 특수화된 버전이 아니라면 기본 클래스로부터 상속받아서는 안된다고 함
		- 파생클래스는 사용자가 그 차이점을 모른채 기본클래스의 인터페이스를 통해서 사용할 수 있어야함
	- 상속받고 싶을때만 상속받게 하라
	- 오버라이드가 불가능한 메소드를 오버라이드 하지 말라
	- 공통으로 사용되는 인터페이스와 데이터, 행위를 상속단계에서 가능한 한 가장 높은 곳으로 옮겨라
	- 인스턴스가 하나 뿐인 클래스를 의심하라 : 싱글톤 클래스는 예외적인경우
	- 파생 클래스가 하나뿐인 기본 클래스를 의심하라 : 개발자가 너무 앞서 설계한 것일수 있음
	- 루틴을 오버라이드 했는데 파생된 루틴 내부에서는 아무것도 하지 않는 클래스들을 의심하라
	- 깊은 상속 구조를 피하라
	- 광범위한 타입 검사보다 다형성을 택하라
		- switch case -> command 패턴
	- 모든 데이터를 보호가 아닌 비공개로 만들어라
		- 상속은 캡슐화를 망가뜨린다
- 멤버함수와 데이터
	- 클래스에 가능한 한 적은 수의 루틴을 유지하라
		- 클래스당 루틴의 수가 늘어나는 것이 오류율 상승과 연관있음을 발견하였음
		- 깊은 상속 트리, 클래스 사이의 밀접한 결합 등이 영향이 큼
	- 원하지 않는 멤버함수와 연산자가 암묵적으로 생성되지 않도록 하라
		- 예를들면 싱글톤 클래스의 생성자
	- 클래스에서 호출되는 루틴의 수를 최소화하라
	- 다른 클래스에 대한 간접적인 루틴 호출을 최소화하라
	- 일반적으로 클래스가 다른 클래스와 협력하는 정도를 최소화하라
- 생성자
	- 가능하다면 모든 멤버 데이터를 모든 생성자에서 초기화하라
	- 비공개 생성자를 사용해 싱글턴 속성을 구현하라
	- 다른 사실이 증명될 때까지 얕은 복사(shallow copy)보다 깊은복사(deep copy)를 택하라
		- 얕은 복사를 하는 이유는 보통 성능향상을 위해서하지만, 깊은 복사를 하여 코드 작성 및 유지보수가 편리하도록 해야함.

### 6.4. 클래스를 작성하는 이유
- 현실 세계의 객체를 모델링
- 추상객체를 모델링
	- 실체는 없지만 다른 실질적인 객체의 추상화를 제공하는 객체를 모델링하기 위함
- 복잡성을 줄인다
- 복잡성을 고립시킨다
- 구현 세부 사항을 숨긴다
- 변경의 효과를 제한한다
- 전역데이터를 숨긴다
- 매개변수 전달을 간소화한다
- 중앙 집중 관리한다
- 코드 재사용을 돕는다
- 프로그램 전체를 고현한다
- 연관된 기능을 패키지로 구성한다
- 특정한 리팩터링을 수행한다
- 피해야할 클래스
	- God 클래스를 생성하지 말라
	- 관련이 없는 클래스를 제거하라
		- 행위는 없이 데이터로만 구성된다면 정말로 클래스인지 생각해보라
	- 동사를 뒤에 붙이는 클래스를 피하라
		- 행위로만 구성된 클래스는 클래스가 아니다.

### 6.5. 프로그래밍 언어와 관련된 이슈
- 프로그래밍 언어마다 클래스에 대한 접근방법은 매우 다양하다.
- 언어별 다형성 구현 방법
	- 자바 : 모든 메소드는 기본적으로 오버라이드가 가능하고 오버라이드를 막기 위해서는 메소드를 final 로 선언하면 된다.
	- C++ : 기본적으로 메소드 오버라이딩이 불가능하다. 오버라이드가 가능하게 하려면 메소드를 virtual 로 선언하면 된다.
	- Visual Basic : 기본 클래스에서 overridable 로 선언되어있어야하며 파생클래스는 override 키워드를 사용해야 한다.
- 다른점
	- 상속 트리에서 오버라이드된 생성자, 소멸자의 작동 방식
	- 예외 처리 조건에서 생성자와 소멸자의 작동 방식
	- 기본생성자의 중요성
	- 소멸자나 종결자(finalizer) 호출되는 시기
	- 할당, 동치(quality)와 같이 프로그래밍 언어에서 기본으로 제공하는 메소드를 오버라이드하는 방법
	- 객체 생성 및 소멸, 객체 선언되고 범위를 벗어날때 처리되는 메모리 처리 방식

### 6.6. 클래스를 넘어서: 패키지
- 패키지 : 객체의 결합을 관리하는 툴
	- 어떤 클래스가 public 이고 어떤 클래스가 패키지 내부에서 사용되기 위한 것인지 구별하는 이름 규약
	- 각 클래스가 어떤 패키지에 속하는지 식별하는 이름 규약 or 코드 구성 규약
	- 어떤 패키지가 다른 패키지를 사용할 수 있는지나 상속, 포함 등으로 사용할수 있는지 정의하는 규칙


## 7장. 고급루틴
- 루틴이란
	- 한가지 목적을 위해서 호출할 수 있는 개별 메소드나 프로시저
		- C++ : 함수 / 자바 : 메소드 / Visual Basic : 함수 or 서브 프로시저

###7.1. 루틴을 작성하는 이유
- 복잡성을 줄인다
	- 데이터 처리 루틴 작성시 해당 데이터를 어떻게 처리할지 고민하지 않아도 된다
	- 루틴의 내부 동작 방식은 몰라도 해당 루틴의 구현사항에 신경쓰지 않고 루틴을 사용할수 있게 됨
	- 내부 루프나 조인문이 깊게 중첩되어 있다면 루틴을 서브 루틴으로 나눠야함. 루틴을 더 이해하기 쉽게 중첩된 부분을 별도의 루틴으로 작성해야 한다.
- 이해하기 쉬운 중간단계의 추상화 도입
	- 여러줄의 긴 루틴을 하나의 루틴(메소드)으로 빼놓으면 이름만으로도 루틴의 행위를 알수 있게 된다.
- 중복 코드를 피한다
	- 코드가 반복되면 루틴을 작성해야함
	- 두 루틴의 비슷한 코드 작성시 오류가 발생한다면 각각의 루틴을 수정하지만 공통코드를 두면, 변경이 필요시 공통코드만 변경하면 된다.
- 서브 클래싱을 지원
	- 길고 구조화가 덜 된 루틴보다 길이가 짧고 구조적으로 완성도 있는 루틴을 오버라이드하면 변경해야할 내용이 많지 않을것
- 코드의 실행 순서를 감춘다
	- 각각의 루틴이 상대 루틴의 호출 순서에 영향을 받지 않도록 해야한다
		- Stack의 pop() 메소드 구현을 위해 Stack의 최상위의 값을 읽고 top 값을 줄이는 코드가 있다면 이 두 코드를 popStack() 에 담으면 두 연산이 수행되는 순서에 대해 고민하지 않아도 됨
- 포인터 연산을 감춘다
- 이식성을 높인다
- 복잡한 boolean 테스트를 단순화함
	- 프로그램 흐름을 이해하기 위해 복잡한 boolean 테스트를 상세하게 이해할 필요는 없다
	- 메소드의 이름으로부터 테스트의 목적을 쉽게 이해하도록 한다.
- 성능 개선
	- 코드를 한곳에 작성해 놓으면 비효율적인 부분을 찾는데 더 쉽게 분석이 가능함
	- 코드를 한 곳에 모아놓으면 한번의 최적화를 통해 루틴을 사용하는 모든 코드에 도움을 줄 수 있음
- 모든 루틴의 길이를 짧게 만들기 위함은 아니다
	- 크기가 큰 하나의 루틴 내에서 처리하는 것이 좋은 경우도 있음
###7.2. 루틴 수준의 설게
- 루틴을 작성하는 목적은 한가지 일을 잘하도록 하는 것에 있다. 잘 작성된 루틴은 응집력이 강하다
	- CosineAndTan() -> 한가지 이상의 작업을 수행함으로 응집력이 약함

### 7.3. 좋은 루틴 이름
- 루틴이 하는 모든 것을 표현하라
	- 루틴 이름에 모든 출력, 부수적 효과를 설명하라
		- 전체보고서를 계산하고 출력파일을 여는 루틴
			- computeReportTotals() -> computeReportTotalsAndOpenOutputFile()
- 의미가 없거나 모호하거나 뚜렷한 특징이 없는 동사를 사용하지 말라
	- 무슨일을 하는지 말해주지 않는 루틴
		- handleCalculation() / performServices() / outputUser() / processInput() / dealWithOutput()
	- 루틴이 처리하는 연산이 모호해서 동사를 모호하게 사용하기도 한다. 이 경우는 해당 루틴과 관련된 루틴들을 재구성하여 모든 루틴이 분명한 목적을 갖고 루틴의 기능을 정확하게 설명하는 이름을 갖도록 재구성하는 것이 가장 좋은 해결책이다.
- 루틴 이름을 숫자만으로 구분하지 말라
	- part1 / part2 /  outputUser1 / outputUser2
	- 루틴 이름 끝의 숫자는 루틴이 표현하는 서로 다른 추상화에 대해서 아무런 정보도 제공하지 않기에 잘못 지은 것
- 루틴 이름의 길이에 신경 쓰지 마라
	- 전반적으로 루틴이름은 명료함에 초점 맞춰야하기에 이름의 길이에 제약받지 말고 이해하기 쉽게 이름을 지어야함
- 함수의 이름을 지을 때는 리턴 값에 관해서 설명하라
	- cos() / CustermerId.Next() / Printer.isReady() / Pen.currentColor()
- 프로시저의 이름을 지을 때 확실한 의미가 있는 동사를 객체 이름과 함께 사용하라
	- 기능적 응집성을 갖는 프로시저는 일반적으로 하나의 객체에 대해 한가지 연산을 수행함
	- 프로시저가 무슨 일을 하는지 반영해야 하기 때문에 객체의 연산은 동사에 객체 이름을 붙여 쓴 형태의 이름을 갖는다.
		- printDocument() / calcMonthlyRevenues() / checkOrderInfo() / repaginateDocument()
	- 그러나 객체지향 언어에서는 객체자체가 호출에 포함되어있어 프로시저에 객체 이름을 포함할 필요는 없음
		- Document.print() / orderInfo.check() / MonthlyRevenues.calc()
- 반의어를 정확하게 사용하라

	| add / remove     	| increment / decrement 	| open / close    	|
	|------------------	|-----------------------	|-----------------	|
	| begin / end      	| insert / delete       	| show / hide     	|
	| create / destroy 	| lock / unlock         	| source / target 	|
	| first / last     	| min / max             	| start / stop    	|
	| get / put     	| next / previous         	| up / down      	|
	| get / set     	| old / new         	    |               	|
- 공통 연산을 위한 규약을 만들어라

### 7.4. 루틴의 길이에 대한 문제
- 짧을 수록 개발 비용이 더 저렴하고 오류 발생확률이 적다고 하나 경우에 따라 길게 작성할수도 있다

### 7.5. 루틴 매개변수 처리
- 매개변수를 입력, 수정, 출력 순서로 입력한다(C 라이브러리 규약과 상충)
	- 루틴이 연산을 처리할때 데이터를 입력받고 변경한 다음 결과를 반환하는 순서로 진행되기 때문	
- 유사한 매개변수가 여러 루틴에서 사용된다면 해당 매개변수를 항상 같은 순서로 입력한다
	- 모든 루틴에 대해 같은 매개변수가 같은 순서로 사용되면 기억하기 쉽다.
	- C의 fprintf()는 파일이 있기에 file을 첫번째 인자로 전달하고 나머지는 printf()와 같다

		```
		int fprintf(FILE * stream, const char * format, ...);
		int printf(const char *format, ...);
		```
	- C의 strncpy(), memcpy() 도 인자의 순서가 같음

		```
		char *strncpy(char *dest, const char *src, size_t n)
		void *memcpy(void *str1, const void *str2, size_t n)
		```
- 모든 매개변수를 사용한다
	- 루틴에 매개변수 전달시 반드시 사용하고, 미사용시 매개변수는 제거한다
	- 사용되지 않는 매개변수 증가시 오류 발생 가능성이 증가한다
- 상태변수나 오류변수를 마지막에 입력
- 루틴의 매개변수를 연산을 위한 변수로 사용하지 않는다
	- 루틴의 매개변수를 중간 계산 결과값을 저장하는 용도로 사용한다면 리턴 되는 값도 이름의 의미가 맞지 않게 된다
	- 새로운 지역변수를 할당하여 그 변수의 역할을 명확하게 나타내는 이름을 사용하라
- 매개변수에 대한 제약사항을 주석으로 작성
	- 제약사항을 주석하는 것보다도 좋은 방식은 assertion 을 사용하는 것
	- 매개변수에 관한 조건
		- 매개변수가 입력을 위한 것인지, 변경되는지, 값을 반환하기 위한 것인지에 대한 내용
		- 숫자 매개변수의 단위(인치, 피트, 미터)
		- 열거형(enumerator)이 아닌 경우 상태 코드와 오류 값의 의미
		- 값의 범위
		- 절대로 가질 수 없는 값
- 루틴 매개변수의 수를 7개 정도로 제한
	- 심리학 연구에 따르면 사람들은 일반적으로 한 번에 7개 이상의 정보 묶음을 추정ㄱ할 수 없다고 한다(Miller 1956)
	- 매개변수 여러개를 함수에 계속 전달하고 있다면 루틴들이 서로 지나치게 묶여 있다고 말할 수 있다. 
	- 결합을 줄일 수 있도록 루틴을 설계하라.
	- 동일한 데이터를 여러 루틴에 전달하고 있다면 그 루틴들을 클래스로 분류하고 자주사용되는 데이터는 클래스 멤버변수로 취급한다
- 매개변수에 사용할 입력, 수정, 출력 이름 규약을 고려한다
- 루틴이 인터페이스 추상화를 유지할 수 있도록 변수나 객체를 전달한다
	- 변수로 전달 : 전에 생성된 데이터 값을 다시 사용한다면 변수로 전달
	- 객체로 전달 : 매개변수들이 동일한 객체로부터 온 것이라면 전체 객체를 전달
- 이름(named) 매개변수를 사용
- 실질적인 매개변수가 형식적인 매개변수(dummy)와 일치하는지 확인
	- 매개변수 목록의 인자 타입을 검사하고 일치하지 않는 매개변수 타입에 대한 컴파일러의 경고에 귀기울여라

### 7.6. 함수를 사용할 때 특별히 고려해야할 사항
- 함수 사용 / 프로시저 사용
	- 언어적 특징이라 이부분은 패스..
- 함수 리턴 값 설정
	- 가능한 모든 리턴 경로를 검사하라
		- 함수를 시작할 때 리턴값을 기본값으로 초기화하면 정확한 리턴 값이 설정되어있지 않은 경우에 대한 안전장치를 제공함
	- 지역 데이터에 대한 참조나 포인터를 리턴하지 말라
		- 루틴이 끝나자마자 지역데이터는 범위를 벗어나고 참조나 포인터는 무효한 상태가 될 것

### 7.7. 매크로 루틴과 인라인 루틴
- C내용이라 패스

## 8장. 방어적 프로그래밍

```
- 제품코드는 "쓰레기를 입력하면 쓰레기가 나온다" 라는 말보다 정교한 방법으로 오류를 처리해야 한다.
- 방어적 프로그래밍 기법은 오류를 찾거나 수정하기 쉽고 제품 코드에 손상을 덜 입힌다.
- assertion은 큰 시스템, 신뢰성 높은 시스템, 빠르게 코드가 변경되는 시스템에서 오류를 초기에 발견하는데 도움이 된다.
- 잘못된 입력 데이터를 처리하는 방법에 대한 결정은 오류 처리와 고수준 설계에서 핵심적인 결정 사항이다.
- 예외는 코드의 정상적인 흐름과 다른 차원에서 오류를 처리하는 방법을 제공한다. 예외는 조심스럽게 사용하면 개발자에게 유용한 도구이며 다른 오류 처리 기법과 견주어가며 사용해야 한다.
- 제품 시스템에 적용되는 제약사항이 반드시 개발 버전에 적용될 필요는 없다. 그러한 사항을 자신에게 유리하게 사용할 수 있으며 오류를 빠르게 검출하는 데 도움이 되는 코드를 개발 버전에 추가할 수 있다.
```


### 8.1. 잘못된 입력으로부터 프로그램 보호
- 외부로부터 들어오는 모든 데이터의 값을 검사하라
	- 데이터를 전달받을 때 데이터가 허용 가능한 범위 안에 있는지 확인하는 검사를 하라
- 루틴의 모든 입력 매개변수 값을 검사하라
	- 위와 상동
- 잘못된 입력을 어떻게 처리할지 결정하라
	- 오류 처리 기법

### 8.2. assertion
- 루틴이나 매크로 실행시 프로그램이 스스로 검사할 수 있도록 하는 코드
- assertion 예시
	- 입력(출력) 매개변수의 값이 예상된 범위 안에 들어가는지
	- 파일 or stream 이 열려있는지, 시작인지, 읽기전용 or 쓰기 전용으로 열려있는지
	- 입력만 가능한 변수의 값이 루틴에 의해 변경되지 않는지
	- null 체크
	- 루틴에 전달되는 배열이나 컨테이너가 적어도 N개의 데이터요소를 포함할 수 있는지
	- 테이블이 실제 값을 포함할 수 있도록 초기화 되었는지
	- 컨테이너의 상태
- 자신만의 assertion 매커니즘 구축
	- C의 경우 assertion 을 #define 으로 매크로 정의할 수 있음
- assertion 사용 지침
	- 발생이 예상되는 상황에 대해서는 오류 처리 코드를 사용하되, 절대로 발생해서는 안되는 조건에 대해서는 어설션을 사용하라
		- 오류 처리 코드는 자주 발생하진 않지만 코드를 작성한 개발자가 예상하는 범위 내에 있고 비정상적인 환경을 검사한다.
	- 실행할 가능성이 있는 코드를 assertion 내에 입력하지 않는다
	- 선행 조건과 후행 조건을 문서화하고 검증하는데 assertion 을 사용하라
	- 매우 견고한 코드 작성 위해서는 assertion 은 무조건 포함하고 그 다음에 오류를 처리

### 8.3. 오류 처리 기법
- 중립적인 값 반환
- 다음에 오는 유효한 데이터로 대체
- 이전과 같은 값을 반환
	- 경우에 따라 다르다.
		- 온도를 읽는 S/W가 온도를 한번 읽지 못했을때 이전의 값을 반환이 가능하나
		- 현금인출기에서 거래 인증시 이전과 같은 값이라면 이건 오류이다.
- 가장 가까운 유효한 값으로 대체한다.
- 경고 메시지를 파일에 기록
- 오류 코드를 반환한다
	- 상태변수에 값을 결정한다
	- 함수의 리턴 값으로 상태 값을 반환한다
	- 프로그래밍 언어에서 제공하는 예외 메커니즘을 사용하여 예외를 던진다
- 오류 처리 루틴 or 객체를 호출한다
	- 오류 처리를 전역적으로 담당하는 객체에 집중시키는 것
	- 오류를 처리해야하는 부분이 집중될 수 있어서 디버깅이 쉬워지나,
	- 오류 처리 부분이 전체 프로그램의 기능들에 밀접하게 결합된다.
- 오류가 발생한 곳에서 오류 메시지 출력
- 상황에 따라 가장 잘 작동하는 방법으로 오류를 처리
- 종료한다

### 8.4. 예외
- 오류가 발생한 상황을 전혀 인식하지 못하는 코드는 오류를 해석하고 오류에 대한 것을 시스템의 다른 부분에 제어를 넘길 수 있다.
- java, c++, visual basic 은 try-catch를 지원하고, 각각 특성이 다르다.
- 예외는 상속과 공통 특성을 가진다. 신중하게 사용하면 복잡성을 줄일 수 있다.
- 예외의 이해점 이해, 예외와 연관된 난관을 피하기 위한 방법
	- 예외를 사용해 무시되어서는 안되는 오류를 프로그램의 다른 부분에 알린다
	- 정말로 예외적인 조건인 경우에만 예외를 던져라
		- 예외 사용시 예상치 못한 조건을 처리하는 것과 복잡성 증가 사이의 균형을 잘 맞춰야한다.
		- 예외는 호출하는 코드가 호출된 코드 내부에서 어떤 예외를 던질 것인지 알아야하므로 캡슐화를 약화한다.
	- 책임을 전가하기 위해서 예외를 사용하지 않는다.
		- 오류를 발생된 코드에서 처리할 수 있다면 직접 처리하는 게 좋다.
		- 오류를 처리할 수 있는데도 처리되지 않은 예외를 던지지 않도록 한다.
	- 생성자와 소멸자에서 예외를 잡을 수 없다면 생성자와 소멸자에서 예외를 던지지 않는다.
		- C++ 에서 메모리 해제하는 부분을 말하는듯..
		- 생성자에서 예외를 던지면 소멸자가 호출되지 않기에 리소스 누수가 있을 수 있을 것
	- 올바른 추상화 수준에서 오류를 던진다
		- 오류를 throw 할때 저수준의 예외 명을 던지는게 아니라 고수준으로, 필요하면 상속을 받아 예외명 클래스를 정의한다
	- 예외를 발생시킨 모든 정보를 예외 메시지에 포함한다.
		- 모든 예외는 코드가 예외를 던질때 감지된 특정한 환경에서 발생한다.
		- 메시지에 예외가 발생한 이유를 이해하는데 필요한 정보를 포함하도록 한다.
		- 배열의 인덱스 예외 :: 배열 인덱스의 최대값, 최소값, 잘못된 인덱스의 값
	- 비어있는 catch 블록을 피한다.
	- 라이브러리 코드가 던지는 예외를 파악한다
		- unchecked exeption이 발생할 수 있는 상황을 확인하여 catch 하도록하자
	- 중앙 집중화된 예외 보고 시스템 구축을 고려한다.
	- 프로젝트의 예외 사용을 규격화한다.
	- 예외의 대안을 고려해본다.

### 8.5. 오류로 인한 손해를 막기 위한 방책
- 바리게이트 전략
	- 특정 인터페이스를 안전한 지역으로 가는 경계로 사용하는 것
	- 안전한 지역의 경계를 지나는 데이터의 유효성을 검사하고 데이터가 유효하지 않다면 적절히 대응
- 수술실 기법
	- 데이터는 수술실 입장이 허용되기 전에 살균됨
	- 수술실에 있는 것들은 모두 안전하다고 여겨진다
	- 설계에서는 핵심적으로 무엇을 수술실에 들여보낼지 말지, 문을 어디에 둘지 등을 결정해야함
- 데이터를 입력할 때 적절한 타입으로 변환한다
	- 입력된 데이터를 적절한 타입으로 변환하라

### 8.6. 디버깅 보조 도구
- 제품의 제약사항을 개발 버전에 무의식적으로 적용하지 않는다
- 디버깅 보조 도구를 초기에 도입
- 공격적 프로그래밍 기법을 사용
	- 예외적인 경우에는 개발 중에도 눈에 띄어야하고 배포되는 버전의 코드가 실행 중일때 복구가 가능한 방법으로 처리되어야 함
	- assert 로 프로그램이 중단되게 함
	- 메모리 할당 오류를 발견할 수 있게 할당된 모든 메모리를 완벽하게 채움
	- 파일 형식과 관련된 오류 확인 위해 할당된 파일이나 스트림을 완벽하게 채움
	- 객체 삭제 전 쓰레기데이터로 채움
	- S/W에서 어떤 오류가 발생하는지 이메일로 보내도록 프로그램을 설정
- 디버깅 보조도구를 제거하는 계획을 세운다
	- 버전관리 도구, ant, make 와 같은 빌드 도구를 사용
	- 기본 제공되는 전처리기를 사용
		- \#define DEBUG
	- 자신만의 전처리기를 작성
	- 디버깅을 위한 루틴을 작성

## 8.7. 제품 코드를 얼마나 방어적으로 프로그래밍할 것인지 정하기
- 중요한 오류를 검사하는 코드를 남겨두라
- 사소한 오류를 검사하는 코드를 제거하라
- 심각한 충돌을 일으키는 코드를 제거하라
- 프로그램이 우아하게 충돌하도록 돕는 코드를 남겨두라
- 기술 지원을 위해서 오류를 기록한다
- 오류 메시지가 친절한지 확인한다

### 8.8. 방어적 프로그래밍에 대해서 한번 더 고민하기
- 방어적 프로그래밍이 지나치면 그 자체로 문제를 일으킨다
	- 모든 곳에서 가능한 모든 방법으로 매개변수를 검사한다면 프로그램이 비대히지고 느려질 것
	- 방어적 프로그래밍에 필요한 추가적인 코드가 S/W를 더욱 복잡하게 만든다


## 9장. 의사코드 프로그래밍 프로세스
### 9.1. 클래스 및 루틴 개발 단계 요약

- 클래스 생성 단계
	- 클래스에 대한 일반적인 설계를 작성
		- 클래스의 구체적인 책임을 정의, 클래스가 숨길 요소가 무엇인지 정의
		- 클래스 인터페이스가 추구할 추상화가 무엇인지 정의
		- 클래스가 다른 클래스로부터 파생될 것인지? 상속을 받을 수 있게 할 것인지 결정
		- 핵심적인 공개메서드 식별, 클래스에서 사용할 중요한 멤버변수 식별 및 설계

	- 클래스 내에 각 루틴을 구현
		- 윗 단계에서 정의한 루틴을 구현
	- 클래스 전체적으로 검토 및 테스트
		- 클래스를 전체적으로 사용할 수 있게 구현하면 개별적인 루틴 수준에서 테스트 수행

- 루틴 작성 단계
	- 루틴 설계 / 설계 검사 / 루틴 코드 작성 / 코드 검토 및 테스트의 반복

### 9.2. 전문가를 위한 의사코드
- 의사코드 : 알고리즘이나 루틴, 클래스, 프로그램이 어떻게 작동할지를 기술하는 자연어 문장과 같은 비형식적인 표기법
- 의사코드를 효과적으로 사용하기 위한 지침
	- 구체적 연산을 정확하게 기술하기 위해 자연어 문장과 같은 형태의 명령문 사용
	- 특정 프로그래밍 언어의 문법적 요소를 피할 것
	- 의사코드는 목적에 초점을 맞추어 작성하여 그 방법을 사용하는 목적을 설명
	- 의사코드로 코드를 생성할 수 있을 정도로 작성. 코드를 쉽게 작성할 수 있을 때까지 더 자세히 의사코드를 개선
- 의사코드 사용시의 장점
	- 검토가 쉬워진다. 소스코드를 보지 않고 상세한 설계를 검토할 수 있다. 의사코드로 인해 낮은 수준의 설계 검토가 쉬워 코드 자체를 검토할 필요가 줄어든다.
	- 의사코드는 반복적인 개선을 지원한다. 높은 수준의 설계 -> 의사코드로 변경 -> 소스코드로 변경
		- 작은 단위로 연속해서 개선하면 세부적인 사항을 낮은 수준으로 구현할 때 설계를 점검할 수 있음
	- 변경하기 쉽다.
		- 몇 줄의 의사코드는 코드 한페이지보다 변경이 쉽다.
	- 의사코드는 주석 작업을 최소화한다.
	- 의사코드는 다른 어떤 형태의 설계 문서보다도 유지보수가 쉽다..

### 9.3. PPP(Pseudocode Programming Process)를 이용한 루틴 구현

- 루틴 설계
	- 선행조건 검사
	- 루틴이 해결할 문제 정의
		- 숨길 정보, 입력, 출력, 루틴 호출 전 선행 조건들
		- 호출한 곳으로 반환하기 전 루틴이 true임을 보장하는 후행 조건들
	- 루틴의 이름 짓기
	- 루틴을 어떻게 테스트할 것인지 결정
	- 표준 라이브러리에서 사용할 수 있는 기능 조사
	- 오류 처리에 대해 생각
	- 효율성에 대해 생각
		- 루틴의 인터페이스의 추상화가 잘 되어있는지, 루틴의 코드가 이해하기 쉬운지 확인
		- 성능에 대해 생각
	- 알고리즘과 데이터형 조사
	- 의사코드 작성
	- 데이터에 대해 생각
	- 의사코드 검사
		- 루틴이 무엇을 어떻게 하는지 충분히 이해해야 코드를 작성할 수 있음
	- 의사코드에서 몇가지 아이디를 내보고 가장 좋은 방법을 선택
- 루틴 구현
	- 루틴의 선언부 작성
	- 첫번째, 마지막 명령문 작성 후 의사코드를 고수준 주석으로 변환
	- 각 주석 아래에 코드를 채움
	- 코드 검사
	- 나머지 정리
- 코드 검사
	- 구현한 코드가 정확한지 확인하기 위해 코드를 검사
	- 작동하는 것처럼 보인다고 해서 옳다고 말할 수는 없음
	- 왜 작동하는지 모른다면 알때까지 연구, 토론 후 다른 설계로 실험
- 루틴을 컴파일
	- 무언가 작성하고 그것이 작동하는지 바로 실행해보는 작업 과정을 어떻게 넘어설 수 있는지 보여주는 것
	- 루틴을 컴파일 하여 최대한 많은 정보를 얻기 위한 지침
		- 컴파일러의 경고 수준을 가장 높은 수준으로 설정
		- 유효성 검사기 사용
		- 모든 오류 메시지와 경고의 원인을 제거
	- 코드를 디버거에서 한단계씩 살펴봄
		- 각 줄의 코드가 예상한 대로 실행되는지 확인
	- 코드를 테스트
	- 루틴의 오류를 제거
- 나머지 정리
	- 루틴의 인터페이스 검사 : 모든 입력 및 출력 데이터 확인, 모든 매개변수가 사용됐는지 확인
	- 설계 품질 검사 : 루틴이 한가지 일만 하며 그 일을 잘 처리하는지 확인, 다른 루틴과 느슨하게 결합되어있고 방어적으로 설계되어있는지 확인
	- 루틴의 변수 검사 : 부정확한 변수의 이름, 사용되지 않는 객체, 변수, 부적절하게 초기화된 객체 검사
	- 루틴의 명령문과 논리적 구조 검사
	- 루틴의 레이아웃 검사
	- 루틴의 문서화 검사
	- 불필요 주석 제거
- 필요할 만큼 반복

### 9.4. PPP대안
- 테스트 주도 개발(TDD)
- 리팩토링
- 계약에 의한 설계
- 해킹

## 10장 변수 사용시 고려할 사항
### 10.2. 변수 선언을 쉽게 만드는 방법
- 암시적 선언 ; 컴파일러가 자동으로 변수의 타입을 선언
	- 실수를 저지를 가능성이 있음 ; acctNum / acctNo
- 암시적 선언을 허용하는 언어에서 프로그램 작성시
	- 암시적 선언 기능을 사용하지 않는다.
	- 모든 변수를 선언한다
	- 이름 규칙을 정한다
	- 변수의 이름을 검사한다

### 10.3. 변수 초기화 가이드라인
- 부적절한 초기화의 문제
	- 변수에 값 할당을 하지 않음
	- 변수의 값이 유효하지 않음
	- 변수의 일부에는 값을 할당하고 나머지에 할당하지 않음
- 초기화 문제를 피하기 위한 가이드라인
	- 변수를 선언할 때 초기화 : 비싸지 않은 방어적 프로그래밍 방법이자 초기화 오류를 막을 수 있는 방법
	- 변수가 처음 사용되는 곳 근처에서 초기화
	- 이상적으로 각 변수가 처음 사용되는 곳 가까이에서 변수를 초기화하고 정의
	- 가능하다면 final, const 사용
		- 변수 초기화 후 다른 값으로 할당되는 것을 막을 수 있음
	- 카운터, 누산기 주의 : 재사용을 한다면 초기화를 잊으면 안됨
	- 클래스 멤버변수를 생성자에서 초기화
	- 다시 초기화해야할 필요가 있는지 검사
	- 이름 상수를 한번 초기화하고 실행 코드로 변수를 초기화
	- 모든 변수를 자동으로 초기화하는 컴파일러 설정 사용
	- 컴파일러의 경고메시지 활용
	- 입력 매개변수의 유효성 검사
	- 메모리 접근 도구를 사용해 부적절한 포인터 검사
	- 프로그램 시작시 메모리 초기화

### 10.4. 범위
- 범위 : 변수의 범위를 말함
- 변수의 일반적가이드라인
	- 변수에 대한 참조를 지역화하라
		- 변수 참조 사이에 있는 코드는 취약한 구간이다
		- 변수에 대한 참조를 가까운 곳에 함께 두어 지역화하는 것이 좋다
	- 변수의 수명을 가능한 짧게 유지
		- 취약 구간을 줄일 수 있음
		- 코드를 쉽게 이해할 수 있게됨
		- 초기화 오류가 발생할 가능성을 줄여줌
		- 코드의 가독성이 높아짐
		- 큰 루틴을 작은 루틴으로 나눌때 유용함
	- 변수의 수명 측정
- 범위 최소화 가이드라인
	- 루프에서 사용되는 변수는 루프를 포함하고 있는 루틴의 시작이 아니라 루프 바로 앞에서 초기화한다.
	- 변수 사용 전까지 변수에 값을 할당하지 않는다
	- 연관된 명령문을 그룹화한다
		- ex) oldData / newData 사용하는 부분을 나눔
	- 연관된 명령문 그룹을 별도의 루틴으로 나눔
	- 처음에는 변수를 최대한 제한하고 필요한 경우에만 변수의 범위를 늘림
		- 변수를 가능한 지역화
		- 작은 범위를 가진 변수의 범위를 늘리는 것보다 큰 범위의 변수를 줄이는 것이 훨씬 어려움
		- 전역은 최후의 수단으로만 사용
	- 변수 최소화에 대한 조언
		- 변수를 지역으로 범위를 제한하면 다른개발자들이 훨씬 기억하거나 이해하기가 쉬움
		- 편리함, 한번에 이해 가능한 수준의 차이는 프로그램을 작성하는 것과 읽는 것 중 어느 것에 중점을 둘 것인지의 문제로 귀결됨
		- 변수를 책임지고 있는 클래스에 변수의 범위를 제한할 수 없다면 다른 클래스와 변수의 데이터를 공유하기 위한 접근 루틴을 작성하도록 해야함

### 10.5. 지속성
- 지속성의 형태
	- 특정한 코드 블록이나 루틴에서만 살아있는 경우
		- for 루프 내의 변수
	- 특정 기간만 살아있는 경우
		- new 로 생성된 변수
	- 프로그램 종료때까지 살아있는 경우
		- 전역변수, 자바의 클래스 변수
	- 영원히 살아있는 경우
		- 프로그램을 실행하지 않을 때 db에 저장한 값을 포함할 값, 파일
- 변수의 값이 변하여 원하는대로 작동되지 않는 문제를 피하기 위한 방법
	- 중요한 변수가 적절한 값을 검사하기 위해 프로그램에 디버그 코드, assertion 사용
	- 변수 사용시 그 변수를 부적절한 값으로 설정. 포인터를 삭제후 null로 세팅
	- 데이터가 지속적이지 않다고 가정하는 코드 작성
	- 모든 데이터는 사용하기 바로 직전에 선언하고 초기화하는 습관을 들일것

### 10.6. 결합시점(binding time)
- 변수와 그 값이 서로 연결된 시간을 의미
	
	```
	titleBar.color = 0xFF;
	
	private static final COLOR_BLUE = 0xFF; -> 이거 하나 변경하면 다 적용됨
	private static final TITLE_BAR_COLOR = COLOR_BLUE;
	```

- 결합 시점이 이를 수록 유연성이 낮아지고 복잡성이 줄어듬

### 10.7. 데이터형과 제어 구조 사이의 관계
- 순차적 데이터 : 프로그램의 순차적 명령문으로 변환됨
	- 5개의 값을 처리하는 5개의 명령문을 일렬로 나열한 것
	- 파일에서 데이터들을 읽는 작업
- 선택적 데이터 : if, case
	- 특정한 시간에 여러개의 데이터 중 오직 하나만 사용되는 데이터 집합
- 반복 데이터 : for, repeat, while

### 10.8. 변수를 한가지 목적으로만 사용하기
- 각 변수를 한가지 목적만을 위해서 사용하라
 	- 변수가 두가지 일을 하게 되면 한 가지 일에 대해 잘못된 형태의 값을 가질 수 있음
- 숨은 의미가 있는 변수를 피하라
- 선언된 모든 변수를 사용하는지 확인
	- 참조되지 않는 변수는 높은 오류 발생률과 상관관계가 있음을 발견
