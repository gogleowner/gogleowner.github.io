---
layout: post
title: "시스템성능구조 1장 정리"
date: 2018-06-12 15:30:00 +0900
categories: book
---

[그림으로 공부하는 시스템 성능 구조](http://www.yes24.com/24/Goods/17947564?Acode=101) 책의 1부 내용을 정리했다.

# Chp1. 성능에 대한 기초적인 개념

## 1.1 성능을 배우기 위해 필요한 것
- 사례로 보는 성능 악화의 원인
	- 처리할 데이터의 건수가 많아져서 프로그램이 느려진 경우
	- 데이터의 양이 적었을 경우엔 빨랐지만, 데이터의 양이 늘어나서 처리 속도가 느려진 경우에는,
	- 맨 메모리의 맨 마지막의 위치를 기억할 수 있는 변수를 두면 속도가 유지될수 있다.

## 1.2 알고리즘의 장단점과 학습방법
### 1.2.1 알고리즘이란?
- 예시 : 길게 늘어져 있는 상자 안에서 원하는 물건을 찾을때 걸리는 시간
	- 1000개의 상자에서 원하는 물건을 찾기 위해 열어야할 상자의 수가 평균 500개
	- 이를 개선한다면?
	- 상자 안의 물건에 번호를 붙여서 순서대로 정렬하여 나열한다. 찾고자 하는 상자의 번호와 중간에 위치한 상자의 번호를 보고 번호보다 크면 번호가 더 큰 상자들 안에서 중간에 위치한 상자의 번호를, 그 반대의 경우에는 번호가 작은 상자의 중간 상자의 번호를 보는 식으로 줄여나가다면 적은 횟수로 원하는 물건을 찾을 수 있을 것이다.
- 이런 전략, 방법을 알고리즘이라고 함.

### 1.2.2 알고리즘의 근간
>위에서 소개한 예시에 이어서, 상자를 찾을 경우와 상자를 넣을 경우를 보여주고 있다.

- 상자를 찾을 경우
	- 앞서 정렬한 1000개의 상자에 상자에 대한 주소를 모두 적어 놓을 경우, 주소만 알면 상자에 바로 접근할 수 있다. 
	- 이를 C언어의 포인터, CPU가 처리하는 '물리 메모리' 방식이라고 말할 수 있다.
- 상자를 넣을 경우
	- 1~100의 숫자를 1000개의 상자에 넣을 경우, 101번째 상자에는 번호가 없다.
		- 50.5를 추가할 경우에는?
			- 방법 1 : 50, 51 사이에 50.5를 넣고 나머지 숫자를 하나씩 옮긴다.
				- 장점 : 숫자가 정렬되어있어 위의 방법대로 상자를 찾을 수 있음. 
				- 단점 : 숫자를 넣을때마다 하나씩 뒤로 옮겨야함
			- 방법 2 : 맨 뒤의 상자 뒤에 50.5를 넣는다.
				- 장점 : 상자를 바로 넣을 수 있음
				- 단점 : 숫자가 순서대로 정렬되지 않음

### 1.2.3 알고리즘을 배우기 위한 방법
- 장점과 단점을 파악한다.
- 그림을 그려서 생각해본다.

## 1.3 알고리즘의 실제 사례와 성능 차이
### 1.3.1 가까이에 있는 알고리즘 예
>항공권 예약을 하는 과정에서 쓰이고 있는 알고리즘이 어떤 자료구조를 사용하는지 보여준다.

- tree :: 검색용 구조
	- 항공권 예약
- sort :: 정렬 구조
	- 정렬 조건은 요금이 저렴한 것 부터
- queue :: 대기 구조
	- 취소 대기 예약
- list :: 저장구조
	- 이름이나 회원번호 등을 넣어놓음.

### 1.3.2 성능에 영향을 끼치는 정도
- 하나의 데이터를 볼 경우 1ms 가 걸린다고 가정하고 100만개의 데이터 중에서 특정 데이터를 검색하는 경우 절반의 데이터를 볼 경우에는 500초가 소요된다.
- 이때 위에서 이야기한 정렬된 데이터를 반씩 확인하는 알고리즘으로 생각해보면, 100만 -> 50만 -> 25만 -> 12.5만 .. 약 20회 정도의 데이터만 보면 된다. 20ms가 소요된다.
- 좋은 알고리즘은 처리가 빠르다.

### 1.3.3 알고리즘을 평가하는 지표
- 계산량
	- y=n, y=2n -> O(n)
	- O(1) -> 데이터 증가에 따른 영향을 받지 않음
- 계산량으로 알고리즘을 평가
	- 앞서 이야기한 효율적인 알고리즘은 binary search tree 구조이다.
		- 나무 뿌리부터 시작해서 목적지에 도달하기 까지 데이터를 반씩 줄여나가는 방식이다.
		- O(logn) : n을 2로 몇번 나누어야 1이 되는지를 의미

## 1.4 응답과 처리량
- 응답(Response) : 얼마나 빠르게 반응할수 있는지
- 처리량(Throughput) : 동시에 처리할 수 있는 양이 몇 건인지
- 응답과 처리량의 관계
	- 동시에 처리할 수 있는 건수를 늘리면 -> 한건당 처리 시간은 빠르지 않지만 특정 시간 내에 처리할 수 있는 건수가 늘어남
	- 응답 중심 : 응답이 빠르면 처리량도 올라간다. 하지만 하드웨어로서 성능을 향상시키는데에는 한계가 있어서 그 이상의 속도를 내기란 불가능하다.


## 1.5 알고리즘의 구체적인 예
### 1.5.1 배열과 루프 처리
- 배열 : 상자가 일정 수 만큼 나열되어있는 구조
- 계산량 : 배열에 데이터가 n개 있을 경우 n회 반복 처리를 하기 때문에 O(n)
- 장점 : 일시적으로 메모리 상에서 처리해야하는 경우 자주 사용됨
- 단점 : 배열 중간에 데이터를 삽입하는 것은 번거로움, 데이터가 증가하거나 빈번히 변경되어야하는 경우 적합하지 않을 수 있음

### 1.5.2 리스트와 루프 처리
- 리스트 : 체인과 같은 구조
- 계산량 : O(n)
- 장점 : 유연하다. 데이터를 넣는 경우 뒤에서, 중간에서, 앞에서 추가하는 경우 배열처럼 값을 모두 이동할 필요가 없다.
- 단점 : 직접접근이 가능하지 않다.

### 1.5.3 트리와 검색
- 트리 : 계층형 자료구조
- 계산량 : O(logn)
- 장점 : 검색시 대상 범위를 절반씩 줄여가는 방식이라 속도가 빠르다.
- 단점 : 데이터가 갱신되는 경우 성능 악화의 문제가 있을 수 있고, 트리의 좌우 균형이 불균형해지면 검색시 O(n)이 걸릴 수 있다.
- 개선 또는 변형 : B트리 - 트리의 높이를 균일하게 유지하는 트리이다. DB나 파일시스템에서 사용한다.

### 1.5.4 해시 알고리즘
- 해시 : 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수
- 가장 쉬운 해시함수는 나머지 계산이다.
- 계산량 : O(1)
- 장점 : O데이터가 늘어나도 (1)의 속도로 검색을 할 수 있다.
- 단점 : 해시키의 충돌이 일어날 수 있다.
	- 해시키의 충돌을 방지하기 위해 Open Addressing, Reference Chaning 방식이 존재한다.


### 1.5.5 큐
- 파이프 안에 공을 하나씩 넣으면 반대쪽 입구에서 하나씩 나오는 처리이다. 순서대로 처리해야하는 작업에 적합하다.
- 계산량 : O(1)
- 장점 : 대량의 처리시, 순서를 기다리는 대기 상태로 유지할 수 있다. 실제 부하를 받는 서버는 큐에 쌓아놓고 처리하는 서버는 하나씩 순서대로, 분산처리를 하여 데이터를 반환하면 이용자의 대기시간이 짧아지고 일시적인 처리가 다수 발생하더라도 안정적으로 처리할 수 있다.
- 단점 : 큐가 무한대가 아니므로 큐가 꽉 찼을 때 클라이언트는 처리가 완료되었는지 실패인지 알수 없다.

### 1.5.6 스택
- 큐와 반대
- 장점 : 필요한 만큼만 공간을 사용하고 공간이 단편화 되지 않는다.
	- OS가 프로그램 호출시 메모리 공간을 낭비하지 않고 여러 함수를 호출하여 처리할 수 있게 한다.
- 단점 : 처음에 넣은 데이터가 마지막까지 방치되는 것
- 개선 또는 변형 : OS의 프로세스 스택 추적, Java 스레드 덤프

### 1.5.7 소트(퀵 소트)

### 1.5.8 캐시 - write back
- 데이터를 갱신할 때 정식 데이터는 갱신하지 않고 캐시 데이터만 갱신했다가 나중에 정식 데이터를 갱신하는 방법
- 장점 : 캐시 데이터만 기록하는 것을 보장하면 되니 속도가 빠르다.
- 단점 : 캐시 데이터가 망가지면 정식 데이터가 오래된 데이터를 보유하고 있을 경우 불일치가 발생할 수 있다.

### 1.5.9 캐시 - write through
- 정식 데이터도 반드시 갱신해야하는 경우
- 장점 : 캐시에 데이터가 있으면 읽기 빠르고, 쓰기 처리 보장된다.
- 단점 : 데이터 기록시 정식 데이터에 기록되기까지의 시간이 걸리기에 응답이 늦어질 수 있다.
- 개선 또는 변형
	- OS상에서 뭔가를 기록할 경우 - 캐시에 임시로 기록해두었다가 반영
	- DBMS 의 경우 로그데이터는 소멸되면 안되므로 로그데이터에 바로 기록하는 형태로 되어있다.

### 1.5.10 락과 성능
- 락의 본질
	- 병렬로 처리할때 필요한 메커니즘
	- 다른 프로그램 또는 쓰레드가 같은 자원을 동시에 갱신할 경우 자원이 망가질 수 있음
	- 이것을 방지하기 위해 누군가 자원을 갱신 중에는 다른 프로그램이 갱신처리를 기다리도록 해야한다. 락은 특정 처리가 진행되고 있는 상태를 보호하기 위한 도구이다.
- 락 대기 상태의 처리
	- 처리가 하나만 있을 때 : 혼잡하지 않으면 대기행렬이 발생할 확률이 낮고, 대기 시간이 길어질 확률도 낮아진다.
	- 혼잡도가 높을 때 : 대기 행렬 발생 확률이 높고, 요청이 계속 쌓일 수 있다.
- 락 대기를 해결할 방법
	- 락이 된 처리를 빨리 끝내기
		- DB테이블에 락을 건 상태에서 쿼리를 실행할 궁우, 쿼리를 빨리 끝내면 락 대기 시간을 줄일 수 있음
	- 락 분할
		- 테이블에 락을 거는게 아니라 row에 락을 걸면, 병렬 실행이 가능하다.


# Chp2. 성능 분석의 기본
## 2.1 성능의 시작은 측정부터
원인을 모르면 대응 방법도 알수 없음
## 2.2 필요한 성능 정보란
### 2.2.1 '샌드위치' 원칙
- 시간적인 전후 관계, 장소적인 전후관계 모두 고려해야함

### 2.2.2 성능정보 세 가지
- 요약형식
	- `$ vmstat 10 3` : 메모리와 CPU 요약정보를 10초 단위로 세번 취득
		- 첫번째 : 지금까지의 축적치
		- 두번째 : 명령 실행 후 10초간의 평균
		- 세번째 : 명령 실행 후 10~20초간의 평균
- 이벤트 기록 형식
	- 개별처리를 순차적으로 기록하는 방식
	- 패킷 캡처, 시스템콜 기록
	- 툴 대부분 성능 데이터가 방대해짐, 부하가 커서 운영환경에는 적용하기 어려움
- 스냅샷 형식
	- `$ ps`, `$ top` 명령어 처럼 순간의 상태를 기록하는 것

### 2.2.3 시스템 구조와 성능 문제 발생시의 동작
- 3계층형 웹 시스템의 경우 웹서버 - AP 서버 - DB서버의 형태로 서버를 둘텐데, 성능 문제가 있을 경우 가장 먼저 파악해야할 것은 아래와 같다.
	- 어디서 문제가 발생했는가?
	- 어디가 막혔는가
- 큐와 쓰레드를 통해 확인한다.
	- 웹서버의 경우 큐나 쓰레드가 쌓여있을 수 있음, 웹서버에서 시간이 걸린다면 처리중인 쓰레드, 처리 대기중인 큐가 꽉 차있을 수 있다.

### 2.2.4 데이터 종류와 분석 비법
- 요약형식
	- 과거 시점의 대략적인 상태 조사에 유리함
	- CPU 사용률, I/O 평균 응답이 나쁘지는 않는지 등의 현상을 파악할 수 있음
- 이벤트 기록 형식
	- 도착과 출발을 의식해야함
	- 장비간 시간 차가 미묘하게 차이날 수 있으므로 같은 장비에서 측정하는게 중요
- 스냅샷 형식
	- 문제 시간 파악시 해당 시간대의 처리만 조사하면 됨

## 2.3 성능 분석시에 중요한 이론
### 2.3.1 대기 행렬 이론의 용어
- 응답시간 : 접근 대기시간 : 서비스 시간
- 식 : M/M/1 
	- M : 요청 도달 시점
	- M : 서비스 시간
	- 1 : 처리 병렬도(1이면 단일 처리)

###2.3.2 대기 행렬의 평균 대기 시간 계산
- 평균사용률 = (처리시간 X 처리 건수) / 단위 시간
- 대기시간 / 처리시간 = 평균사용률 / (1 - 평균사용률)
- 예시
	- 처리시간을 1초, 처리 건수를 1시간당 3,000건이라고 하면,
	- 평균사용률 = 3000 / 3600 = 0.83
	- 대기시간 / 1초 = 0.83 (1 - 0.83)
	- 대기시간 = 4.88
	- 응답시간 = 4.88(대기시간) + 1(처리시간)
- 사용률이 100%가까이 되면 대기시간이 지수함수 형태로 길어진다. 이는 긴 대기행렬이 발생하는 것을 의미
	- 사용률 10% -> 응답시간 변하지 않음
	- 사용률 85% -> 응답시간이 배가 됨

###2.3.3 사용률과 대기 행렬의 예
- 스파이크 : CPU 사용률이 갑자기 튀는 부분
	- 스파이크를 확인하면 정기적으로 확인하여 새로운 스파이크가 증가하지 않았는지 살펴봐야함.
- 병렬 처리 정도가 낮으면 CPU 사용률과 대기행렬에 주의가 필요

### 2.3.4 정보 취득 방법
- 각 서버 OS
	- vmstat 5초간격 상시
	- iostat 1분 간격 상시(DB서버처럼 I/O가 많은 서버에 해당)
	- ps or top 5분 간격
- 웹서버, AP 서버
	- access 로그 상시
	- AP 서버의 처리 대기 큐 정보 상시
	- AP 서버의 쓰레드 사용 상태 정보 상시
	- AP 서버의 DB연결 상태 정보 상시
	- 자바의 경우 GC 로그 상시
- DB 서버
	- DBMS의 요약정보(ex: AWR) 30분 간격 상시
	- DB 세션의 스냅샷(ex: ASH, Active Session History) 상시


## 2.4 OS 명령
### 2.4.1 sar
- 성능정보 종류 : 요약 형식
- 어디서 측정하고 있는가?
	- OS 커널을 통해 취득할 수 있는 OS 정보 제공
	- OS 레벨이기에 App에서 본 I/O 정보와 다를 수 있음
- 알 수 있는 것
	- CPU 사용률, 유휴(idle) 상태, 읽기/쓰기 시의 I/O 양, 메모리의 대략적인 상태
- 알 수 없는 것
	- 프로세스 단위 상태, 순간적인 성능 문제, 원인이 되는 프로그램, 하이퍼 스레드 등의 실제 CPU 사용상태는 알 수 없음
- 기타
	- 자동으로 기록되기 때문에 대략적인 상황 파악을 위해 과거 내역을 확인할 수 있다.
	- sar 명령 자체가 부하가 높지는 않다.
	- 다만 정보 출력 항목 수가 적어서 정작 필요한 정보의 취득이 어려운 경우가 있다.

### 2.4.2 vmstat
- 성능정보 종류 : 요약 형식
- 어디서 측정하고 있는가?
	- OS 커널을 통해 취득할 수 있는 OS 정보를 보고 있다.
- 알 수 있는 것
	- 실행 대기 중인 평균 프로세스 수, 어떤 이유로 대기하고 있는 평균 프로세스 수, CPU 사용률, swap I/O, 보통 I/O, 컨텍스트 스위치 횟수 등
- 알 수 없는 것
	- 프로세스 단위 상태, 순간적인 성능 문제, 원인이 되는 프로그램이나 프로세스, CPU 코어 상태의 차이
- 기타
	- 단기간에 취득해도 문제가 없는 명령
	- 초 단위로 설정하여 모니터링 할 수 있다.
- 명령어 예시
	- `$ vmstat 5 5` 5초 간격으로 5회 실행
	- `$ vmstat 1` 1초 간격으로 계속 실행

###2.4.3 ps
- 성능정보 종류 : 스냅샷 형식
- 어디서 측정하고 있는가? 
	- OS 커널을 통해 취득할 수 있는 OS 정보를 보고 있다.
- 알 수 있는 것
	- 실행 시점에 어떤 프로세스가 상주하고 있는지
	- 실행 시점의 프로세스 상태
	- 프로세스 이름 또는 명령어, PID, CPU 사용 누적시간
- 알 수 없는 것
	- 메모리나 CPU 사용률 등의 대략적인 상태, 실행 중인 각 쓰레드 정보는 초기 설정 상태에서는 알 수 없다.
- 기타
	- 부하가 높은 명령어이기에 짧은 주기로 반복 실행하기에는 적합하지 않다.

### 2.4.4 netstat
- 성능정보 종류 : 요약 형식(성능 통계정보) 및 스냅샷 형식(라우팅 정보 등)
- 어디서 측정하고 있는가
	- 드라이버 수준. 케이블을 직접 측정하는 것은 아니기에 네트워크 문제를 반드시 검출할 수 있는 것은 아님
- 알 수 있는 것
	- `-a` : 실행 시점의 소켓 정보
	- `-r` : 실행 시점의 라우팅 정보
	- `-i` : 인터페이스 단위의 통계정보
- 알 수 없는 것
	- 네트워크 통신에 문제가 발생했는지 알 수 없음
	- 최근에는 드라이버 수준의 통계가 잡히지 않는 문제가 많이 발생하여, 명령어로 에러,손실이 높지 않아도 문제가 발생하는 경우가 있다.
	- `-i` 로 통신량을 확인하는 경우, 데이터 통신 량은 누적된 값이라 지속적으로 본다면, 차이를 계산하여 해당 시간의 통신량을 구할 수 있음
- 함께 보면 효과적인 성능 정보
	- 네트워크 성능이 이상하다고 느꼈다면 해당 네트워크 통신을 사용하고 있는 app의 성능 로그 or 패킷 캡처를 통해 이벤트 로그를 취득하면 드라이버 수준에서는 괜찮은 것 처럼 보여도, app 수준에서 문제가 있는 경우가 많다.


### 2.4.5 iostat
- 성능정보 종류 : 요약 형식
- 어디서 측정하고 있는가
	- 블록 장비 수준. OS 커널 내부이다. 이때문에 파일 캐시 같은 OS 파일 시스템 수준의 동작은 기록되지 않는다.
- 알 수 있는 것
	- 디스크 사용률
	- `-x` : 응답시간, 각종 큐 길이
	- 큐의 길이를 통해 I/O가 얼만큼 발행 혹은 기다리는지 알 수 있다.
- 함께 보면 효과적인 성능 정보
	- 실제 분석을 위해서는 IOPS, 처리량 개념과 같이 봐야함
		- IOPS(Input/Output Operations Per Second, IOPS)는 HDD, SSD, SAN 같은 컴퓨터 저장 장치를 벤치마크하는 데 사용되는 성능 측정 단위다.
	- DB 서버와 같이 I/O 가 중요한 서버나 디스크로 인해 문제가 자주 발생하는 서버 상태 확인시에 용이하다.


### 2.4.6 top
- 성능정보 종류 : 스냅샷 형식
- 어디서 측정하고 있는가?
	- OS 수준의 정보
- 알 수 있는 것
	- 실시간으로 OS 전체 상태를 파악할 때 유용함
	- 요약된 정보를 적절하게 갱신해가며 보여줌
	- 어떤 프로세스가 많이 동작하는지 알 수 있어 문제 발생의 원인을 쉽게 조사할 수 있음
- 알 수 없는 것
	- 활동이 적은 프로세스 정보는 알 수 없다. 이를 알려면 ps 를 활용하자
- 함께 보면 효과적인 성능 정보
	- DBMS 의 경우 해당 시점에 실행중인 SQL 정보를 확인하면 좋다. 취득할 수 없다면 프로세스에 대한 pstack(각 프로세스에 대한 스택 추적을 표시)을 취득한다.
- 기타
	- 약간 부하가 높은 명령어이다.

### 2.5.7 패킷 덤프(wireshark, tcpdump 등)
- 성능정보 종류 : 이벤트 기록 형식
- 어디서 측정하고 있는가?
	- 드라이버 수준 정보
- 알 수 있는 것
	- 어떤 통신을 하고 있는지 상세하게 파악 가능
	- 패킷 정보를 보면 어느 쪽이 처리 중이고 대기중인지 파악이 가능함
- 기타
	- root 사용자만 실행할 수 있는 툴이다.
	- OS 상에서 패킷 덤프 실행시 성능에 큰 영향을 끼친다.

### 2.4.8 pstack
- 성능정보 종류 : 스냅샷 형식
- 어디서 측정하고 있는가
	- OS 가 보는 콜 스택 정보
- 알 수 있는 것
	-  해당 프로세스가 실행 순간 어떤 처리를 하고 있는지 알 수 있음
	-  스냅샷이므로, 반복 실행하여 정보를 취득해야 함
	-  프로그램이 무언가의 처리를 기다리고 있다면 pstack을 실행해도 같은 콜 스택에서 기다리게 된다.
-  알 수 없는 것
	- pstack은 스냅샷이기에 계속 같은 상태에 있는 것을 단정지을 수 없다. 같은 상태인지 조사하렴녀 이벤트 기록 형식 툴을 함께 확인해야할 필요가 있음
	- OS가 보는 콜 스택이기에 app에서 호출하는 메소드 또는 함수명과 다를 수 있다.
- 함께 보면 효과적인 성능 정보
	- 이벤트 기록 형식 툴과 함께 사용시 대기 상태인 것과 그 상태에서 벗어났는지 증명이 가능
- 기타
	- pstack은 부하가 낮다고 알려져 있다.

## 2.4.9 시스템 콜(strace 등)
- 성능정보 종류 : 이벤트 기록 형식
- 어디서 측정하고 있는가
	- OS가 보는 프로세스의 시스템 콜 정보
- 알 수 있는 것
	- 어떤 시스템 콜에서 기다리고 있는지, OS의 어떤 함수에서 시간이 걸리고 있는지 알 수 있다.
- 알 수 없는 것
	- app 내부 어디쯤에서 시간이 걸리는지는 알수 없다.
- 함께 보면 효과적인 성능 정보
	- top 명령을 통해 어떤 프로세스가 의심스러운지 파악하고, 필요에 따라 strace 를 실행
	- 이때 pstack 을 통해 대기 상태가 되어있는 콜 스택 정보도 확인하면 더욱 좋다.
- 기타
	- strace 는 다른 조사 방법이 없을 때 사용
	- 부하가 높다.

### 2.4.10 프로파일러(Profiler)
- 성능정보 종류 : 요약형식
- 어디서 측정하고 있는가
	- OS가 본 특정 프로세스의 함수 처리 시간
- 알 수 있는 것
	- 어떤 함수가 몇번 호출되었는지, 어떤 함수에서 시간이 걸리고 잇는지 알 수 있다.
- 알 수 없는 것
	- 순간적으로 발생하는 문제의 원인은 알기 어렵다.
- 함께 보면 효과적인 성능 정보
	- 가능하면 이벤트 기록형식 정보도 보자, 이를 통해 처리 중인 OS, I/O, 네트워크에 의한 대기 상태가 발생했는지 알 수 있다.
- 기타
	- 개발자가 개발환경에 있는 프로그램 전체 중 어디에서 시간이 걸리는지 조사할 때 유용함
	- OS환경에 다라 명칭이 다르다.
 